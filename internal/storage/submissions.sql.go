// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: submissions.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (problem_id, user_id, solution_code)
VALUES ($1, $2, $3)
RETURNING id, problem_id, user_id, solution_code, status, created_at, last_modified, message, retries
`

type CreateSubmissionParams struct {
	ProblemID    int32       `db:"problem_id" json:"problem_id"`
	UserID       pgtype.UUID `db:"user_id" json:"user_id"`
	SolutionCode string      `db:"solution_code" json:"solution_code"`
}

func (q *Queries) CreateSubmission(ctx context.Context, db DBTX, arg CreateSubmissionParams) (Submission, error) {
	row := db.QueryRow(ctx, createSubmission, arg.ProblemID, arg.UserID, arg.SolutionCode)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.SolutionCode,
		&i.Status,
		&i.CreatedAt,
		&i.LastModified,
		&i.Message,
		&i.Retries,
	)
	return i, err
}

const getSubmissionForUser = `-- name: GetSubmissionForUser :one
SELECT
    problems.title AS problem_name,
    submissions.id, submissions.problem_id, submissions.user_id, submissions.solution_code, submissions.status, submissions.created_at, submissions.last_modified, submissions.message, submissions.retries
FROM submissions INNER JOIN problems ON submissions.problem_id = problems.id
WHERE submissions.user_id = $1 AND submissions.id = $2
`

type GetSubmissionForUserRow struct {
	ProblemName string     `db:"problem_name" json:"problem_name"`
	Submission  Submission `db:"submission" json:"submission"`
}

func (q *Queries) GetSubmissionForUser(ctx context.Context, db DBTX, userID pgtype.UUID, iD pgtype.UUID) (GetSubmissionForUserRow, error) {
	row := db.QueryRow(ctx, getSubmissionForUser, userID, iD)
	var i GetSubmissionForUserRow
	err := row.Scan(
		&i.ProblemName,
		&i.Submission.ID,
		&i.Submission.ProblemID,
		&i.Submission.UserID,
		&i.Submission.SolutionCode,
		&i.Submission.Status,
		&i.Submission.CreatedAt,
		&i.Submission.LastModified,
		&i.Submission.Message,
		&i.Submission.Retries,
	)
	return i, err
}

const getUserSubmissions = `-- name: GetUserSubmissions :many
SELECT
    problems.title AS problem_name,
    submissions.id, submissions.problem_id, submissions.user_id, submissions.solution_code, submissions.status, submissions.created_at, submissions.last_modified, submissions.message, submissions.retries
FROM submissions INNER JOIN problems ON submissions.problem_id = problems.id
WHERE submissions.user_id = $1
`

type GetUserSubmissionsRow struct {
	ProblemName string     `db:"problem_name" json:"problem_name"`
	Submission  Submission `db:"submission" json:"submission"`
}

func (q *Queries) GetUserSubmissions(ctx context.Context, db DBTX, userID pgtype.UUID) ([]GetUserSubmissionsRow, error) {
	rows, err := db.Query(ctx, getUserSubmissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSubmissionsRow
	for rows.Next() {
		var i GetUserSubmissionsRow
		if err := rows.Scan(
			&i.ProblemName,
			&i.Submission.ID,
			&i.Submission.ProblemID,
			&i.Submission.UserID,
			&i.Submission.SolutionCode,
			&i.Submission.Status,
			&i.Submission.CreatedAt,
			&i.Submission.LastModified,
			&i.Submission.Message,
			&i.Submission.Retries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrySubmissionDueToInternalError = `-- name: RetrySubmissionDueToInternalError :one
UPDATE submissions
SET retries = retries + 1
WHERE id = $1
RETURNING id, problem_id, user_id, solution_code, status, created_at, last_modified, message, retries
`

func (q *Queries) RetrySubmissionDueToInternalError(ctx context.Context, db DBTX, id pgtype.UUID) (Submission, error) {
	row := db.QueryRow(ctx, retrySubmissionDueToInternalError, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.SolutionCode,
		&i.Status,
		&i.CreatedAt,
		&i.LastModified,
		&i.Message,
		&i.Retries,
	)
	return i, err
}

const updateSubmissionStatus = `-- name: UpdateSubmissionStatus :one
UPDATE submissions
SET status = $2, message = $3
WHERE id = $1
RETURNING id, problem_id, user_id, solution_code, status, created_at, last_modified, message, retries
`

type UpdateSubmissionStatusParams struct {
	ID      pgtype.UUID      `db:"id" json:"id"`
	Status  SubmissionStatus `db:"status" json:"status"`
	Message pgtype.Text      `db:"message" json:"message"`
}

func (q *Queries) UpdateSubmissionStatus(ctx context.Context, db DBTX, arg UpdateSubmissionStatusParams) (Submission, error) {
	row := db.QueryRow(ctx, updateSubmissionStatus, arg.ID, arg.Status, arg.Message)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.UserID,
		&i.SolutionCode,
		&i.Status,
		&i.CreatedAt,
		&i.LastModified,
		&i.Message,
		&i.Retries,
	)
	return i, err
}
